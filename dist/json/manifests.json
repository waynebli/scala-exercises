{
  "title": "Manifests",
  "modules": [
    {
      "preparagraph": "Note: In Scala 2.10, scala.reflect.ClassManifests are deprecated, and it is planned to deprecate scala.reflect.Manifest in favor of TypeTags and ClassTags in an upcoming point release. Thus, it is advisable to migrate any Manifest-based APIs to use Tags.  When Java-the-language added generic types in version 1.5, Java-the-virtual-machine (JVM) did not. Generic types are a fiction of the compiler. They exist at compile time, but they are omitted from the generated bytecode and are therefore unavailable at run time. This phenomenon is known as erasure. Java's type erasure leads to some peculiar limitations. To deal with these limitations, Java programmers often find themselves passing around `java.lang.Class<T>` objects: concrete manifestations of the otherwise abstract concept that is the type `T`.\n\nScala 2.8  formalized the ability to encode type information into implicit parameters. It does this through two mechanisms: Manifests and implicit type constraints. Manifests were added specifically to handle arrays. This was done because in Scala arrays are generic classes, however on JVM they are encoded differently(`Array[Int]`, `Array[Double]` as opposed to `int[]` and `double[]`).\n\nFor example, the following code will not compile as the compiler does not have enough information to decide on the runtime type of the resulting array:\n\n```\ndef tryMe[T](array: Array[T]) = Array(array(0))\n```\n\nHowever, we can use Manifest to correct that:\n\n```\ndef tryMe[T : Manifest](array: Array[T]) = Array(array(0))\n```\n\nTo use *Manifests*, simply add an implicit `scala.reflect.Manifest[T]` parameter to your method, like so:\n\n```\ndef name[T](implicit m: scala.reflect.Manifest[T]) = m.toString()\n```\n\nThis method prints the name of any Scala type. To use it, invoke the method with some type parameter:\n\n```\nname[Int => Int] // returns \"scala.Function1[Int, Int]\"\n```\n\nWhen using implicit parameters, you usually have to declare a implicit identifier with the same type as your method expects, in the same scope where the method is called. With *Manifests*, the compiler automatically injects the implicit parameter for you, as long as it has enough type information to generate a *Manifest*. Essentially, this is a way of carrying over type information available at compile time into objects available at run time.",
      "code": "def inspect[T](l: List[T])(implicit manifest: scala.reflect.Manifest[T]) = manifest.toString()\nval list = 1 :: 2 :: 3 :: 4 :: 5 :: Nil\ninspect(list) should be(__)",
      "solutions": [
        "\"Int\""
      ],
      "postparagraph": ""
    },
    {
      "preparagraph": "Manifests can be attached to classes. *Manifests* have other meta-information about the type erased:",
      "code": "class Barrel[T](implicit m: scala.reflect.Manifest[T]) {\n  def +(t: T) = \"1 %s has been added\".format(m.runtimeClass.getSimpleName)\n}\nval monkeyBarrel = new Barrel[Monkey]\n(monkeyBarrel + new Monkey) should be(__)",
      "solutions": [
        "\"1 Monkey has been added\""
      ],
      "postparagraph": ""
    }
  ]
}
